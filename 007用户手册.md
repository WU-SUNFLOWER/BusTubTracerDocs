# BusTubTracer 用户手册

开发小组：A7小组（BusTubTracer Project）

编写日期：2024.12.16

# 前言

## 什么是BusTubTracer

BusTubTracer是一款基于BusTub开发的关系型数据库管理系统（RDBMS）底层工作原理和内部数据结构的可视化工具，旨在帮助初学RDBMS底层原理（尤其是[CMU-15445/645课程](https://15445.courses.cs.cmu.edu/)）的计算机类专业学生更好地掌握RDBMS系统设计与实现中的关键概念。

[BusTub](https://github.com/cmu-db/bustub)是由[Carnegie Mellon University](https://www.cs.cmu.edu/)推出的一款开源教学型RDBMS系统。该系统仿照实际的商用RDBMS系统，实现了简单SQL查询、索引等基本功能，是计算机专业学生学习RDBMS底层设计实现和工作原理的宝贵资源。

BusTubTracer基于原版BusTub进行二次开发，在原版的基础上增加了可视化图形界面，用于直观展示BusTub内部的一些重要数据结构，以及BusTub针对SQL命令的处理和执行过程。

## 本手册的目的

作为用户手册，本手册中我将主要介绍BusTubTracer的安装方法和各主要界面的基本操作。

此外，针对先前缺乏数据库原理相关背景知识和不熟悉BusTub的新手用户，我还特别在每个界面的介绍章节中提供了相关技术背景的介绍，以帮助这部分用户快速上手。

# 安装与启动BusTubTracer

## 安装

与原版BusTub一样，BusTubTracer运行在Ubuntu系统上（推荐使用Ubuntu 22.04）。因此如果你的电脑安装的是Windows系统，那么需要首先在VMware等虚拟化软件中安装Ubuntu系统，再进行BusTubTracer软件的安装。

BusTubTracer以`.deb`格式的安装包形式分发给用户，其安装和卸载非常简单。

安装命令：

```shell
sudo dpkg -i <deb安装包路径>
```

卸载命令：

```shell
sudo dpkg -r BusTubTracer
```

## 启动

成功执行`dpkg -i`命令后，如下图所示，在Ubuntu系统的`Show Applications`界面中找到BusTubTracer的应用图标，然后点击启动即可。

![](images/user_manual/installed.png)

软件启动后，默认会进入如下界面。其中上方的五个按钮共同组成导航栏，下方的大区域则为主界面区。你可以通过导航栏实现软件主界面之间的切换。

![](images/user_manual/after_started.png)

在用户手册接下来的部分，我将向你逐一介绍导航栏所对应的五个主界面各自的功能和操作方法。

此外我还需要告诉你的是，在你启动BusTubTracer的时候，它就会启动为你启动BusTub数据库，并与之建立连接，整个过程无需你的干预。

同时，为了降低上手难度，BusTubTracer也会在启动时，预先在数据库中自动为你创建若干张体验用的数据表。具体如下：

| 表名              |      字段                                     |  内容说明                                                     |
|----------         |-------------                                  |------                                                        |
| department        |   (id int, name varchar(128)) | $1600         | 计算机学院的各个系室                                           |
| teacher           |   (id int, name varchar(128), did int)        | 计算机学院各个教师的姓名和所属系室                              |
| course            |   (id int, name varchar(128), credit int)     | 计算机学院开设的各门课程及其学分                                |
| course_teacher    |   (cid int, tid int)                          | 多对多连接表，计算机学院开设的课程各由哪些老师任教                |
| test_table_1      |   (colA int, colB int, colC int, colD int)    | 共40条记录，colA字段的取值顺次为0~39，其余各个字段用随机数填充    |
| test_table_2      |   (colA int, colB int, colC int, colD int)    | 共80条记录，colA字段的取值顺次为0~80，其余各个字段用随机数填充    |
| test_table_3      |   (colA int, colB int, colC int, colD int)    | 共400条记录，colA字段的取值顺次为0~400，其余各个字段用随机数填充  |


# Home界面介绍

## 界面操作说明

Home界面由左右两部分组成，其中右侧部分为一个可以使用鼠标左右拖拽的侧边栏。

左侧为主控制台区，你可以在该区域下方的输入框中直接输入你想提交到数据库执行的SQL命令，并敲击键盘回车或者单击Submit按钮即可。

为了方便初学者上手，我们也在主控制台的欢迎信息中提供了一些示例SQL命令。你可以直接点击这些示例命令，此后相应的命令会被直接填充到下方输入框中。

当命令执行成功后，如下图所示，主控制台区会立即显示出SQL命令的查询结果。

![alt text](images/user_manual/after_submit_sql.png)

Home界面右侧的侧边栏提供了快速查看当前数据库中已有数据表，以及每张数据表中已有内容记录的功能。这个操作比较简单，就不多介绍了。

我这里需要告诉你的是，每当数据库中数据表或其中的记录发生变化时，侧边栏中显示的信息都会实时发生变化。例如下图，当我向`teacher`表中新插入一条记录时，若侧边栏恰好选中`teacher`表，则其中显示的该表记录将自动发生更新。

![alt text](images/user_manual/sync_update.png)

假如你是SQL语言初学者，通过这个特性，你可以通过实时观察侧边栏中显示内容的方式，来方便地了解你执行的SQL命令会对数据表中的内容产生何种影响，进而加深你对SQL语言的掌握。

# Process界面介绍

## 技术背景介绍：BusTub的Query Executor Layer工作原理

Process主界面主要用于展示BusTub中执行层（Query Executor Layer）是如何处理和执行你所提交的SQL命令的。在介绍该界面的操作方法之前，为了便于你理解该界面中所会展示的内容，我首先需要简单向你介绍一下BusTub执行层的工作原理。

在BusTub中，首先会对文本形式的SQL命令进行语法解析，将其转换为抽象语法树（AST树）。随后，会对AST树进行扫描，得到初步的查询计划树（Planner Tree）。

例如，对于如下的SQL命令：

```sql
select * from teacher, department where teacher.did = department.id;
```

BusTub会生成如下的查询计划树：

![alt text](images/user_manual/planner_tree.png)

要理解查询计划树所表达的涵义，你首先需要理解"数据流向"的概念。从图中你可以观察到，查询计划树的叶子节点即为SQL命令中要进行查询的那两张数据表。它们上方的箭头即表示数据（记录）从数据表中流出，流入箭头所指的节点当中，并且会在这些节点中被进一步处理，而处理后的数据又会进一步流入当前节点箭头所指的上层节点当中。经过如此迭代，最终从查询计划树的根节点流出的那些记录，即为SQL命令的最终查询结果。

理解了查询计划树所表达的涵义，接下来我们来看看如何解读图中的这棵计划查询树。首先，树中最底层的两个`SeqScan`节点表示分别从两张表中逐个读取记录。这些读取出来的记录最终会流入`NestedLoopJoin`节点。

`NestedLoopJoin`节点的作用在于对`SeqScan`节点所读取出的两张表进行等值连接（也称作内连接，Inner Join）。在不附加任何条件的情况下，等值连接的效果相当于对两张表作笛卡尔积。

例如，假设`SeqScan`节点读到的两张表的内容分别为

|id     |name   |did    |
|-----  |------ |------ |
|0      |KDK    |0      |
|1      |XB     |1      |

和

|id     |name                       |
|-----  |------                     |
|0      |Computer Science           |
|1      |Software Engineering       |

那么`NestedLoopJoin`节点的输出结果就应该是

|teacher.id     | teacher.name      | teacher.did       | department.id | department.name       |
|-----          |------             |------             | ---------     | --------              |
|0              |KDK                |0                  | 0             | Computer Science      |
|0              |KDK                |0                  | 1             | Software Engineering  |
|1              |XB                 |1                  | 0             | Computer Science      |
|1              |XB                 |1                  | 1             | Software Engineering  |

`NestedLoopJoin`节点输出的临时表会被继续向上推送给`Filter`节点。此节点会对临时表中的记录进行过滤，筛选出符合过滤条件的记录再次组成新的临时表，并继续向自己的父节点推送。

本例中`Filter`节点的过滤条件为`(#InputTuple0[2]=#InputTuple0[3])`，用自然语言表述就是"保留输入表格中（从0开始数的）第2个字段与第3个字段相同的记录"，这对应了你所输入的SQL命令中`where teacher.did = department.id`这部分内容。

因此`Filter`节点所输出的临时表就是

|teacher.id     | teacher.name      | teacher.did       | department.id | department.name       |
|-----          |------             |------             | ---------     | --------              |
|0              |KDK                |0                  | 0             | Computer Science      |
|1              |XB                 |1                  | 1             | Software Engineering  |

根节点`Projection`执行投影操作，即对输入表中每条记录仅保留特定的某几个字段，然后作为新的临时表输出。本例中`Projection`节点的投影表达式为`[#InputTuple0[0], #InputTuple0[1], #InputTuple0[2], #InputTuple0[3], #InputTuple0[4]]`，翻译成自然语言就是"投影输入表中的第0、1、2、3和4字段"，这对应于你输入的SQL命令中的`select *`这部分内容。

> 如果你足够敏锐，应该注意到无论是`Filter`节点还是`Projection`节点，都会有一些表达式之类的信息附着在它们上面。事实上，在BusTub中各种不同类型的节点都会被附着一些特定的信息，即节点的**属性（attribution）**。在附录中，我列举了每一种节点上所可能附加的属性，你可以在学习BusTub的过程中随时进行查阅。

至此你应该已经基本理解了查询计划树的工作原理。

同时，你或许也注意到了一些问题：
- 树中的`Projection`节点似乎没有存在的必要，因为SQL命令中写的是`select *`，并不需要手工去掉某些字段再输出最终结果。
- 既然需要对`NestedLoopJoin`节点输出的结果再次进行过滤，那么能否直接在该节点作等值连接操作时，就执行原本属于`Filter`父节点的过滤条件？

这两个问题的答案都是Yes。

实际上，诸如此类的问题就属于SQL查询优化的范畴了。在BusTub中，也实现了简单的查询优化器。虽说叫"查询优化"，实则是对前面介绍的查询优化树进行优化，而优化可能具体表现为消除冗余节点、用执行效率更高的具备等效功能的节点替换掉原节点等多种形式。

以下展示了BusTub中优化器对前述执行计划树优化的结果，即所谓的Optimized Planner Tree：

![](images/user_manual/opt_planner_tree.png)

到此BusTub中Query Executor Layer的基本原理就介绍得差不多，但必须说明的是，在BusTub的真实实现中，在完成查询优化后，实际上还会遍历整一颗优化查询计划树，生成相应的执行器树（Executor Tree）。执行器树上的每一个节点都对应于优化查询计划树上的某一个节点，并维护一个指针指向它，如下图所示。

![](images\user_manual\exec_tree.png)

最终实际实现的Query Executor Layer会从根节点开始，自顶向下递归整一棵执行器树，并按递归顺序调用挂载在每一个执行器节点上的操作函数来实现对临时表中数据的处理。

每一个执行器节点操作函数都需要依据对应查询计划树上的某些属性来执行。例如，`Filter Executor`节点就需要根据对应`Filter Planner`节点上挂载的`prediction`属性（过滤条件）来决定保留输入临时表中的哪些记录。

## 界面操作说明

BusTubTracer中上方导航栏Process按钮默认处于禁用状态。当你在Home界面的控制台中成功执行一条SQL命令后，该按钮会解锁。之后你就可以进入Process界面查看该条SQL命令的执行过程。

![alt text](images/user_manual/to_see_process.png)

Process的界面如下图所示，其中左侧子面板为导航栏，你可以通过它来切换查看前面介绍的SQL命令执行的三个不同过程。中间子面板会显示当前执行阶段BusTub所生成的树状数据结构的可视化图示。你可以点击树上的任意节点，以查看挂载在该节点上的属性，这部分内容会在右侧子面板中展示。

![alt text](images\user_manual\process_ui.png)

> 你可能会注意到，中间面板每个节点上都会标记一个数字，这是该节点的ID号。在BusTub内部，会通过这个ID号来区分不同的节点。

如果你点击查看Executor Tree上的节点，那么在右侧子面板中显示的内容会更加丰富。除了其对应的Planner Node的属性外，还包括BusTub实际遍历执行整棵树时，流入该节点的临时表，以及从该节点流出的临时表。从根节点中流出的临时表，即为最终的查询结果。

![alt text](image.png)

> 如果你想要直观学习
> - BusTub中的查询优化策略：你可以对比各种复杂的SQL命令所生成的Optimized Planner Tree，相比原先的Planner Tree出现了哪些变化。
> - BusTub中Executor Tree上不同节点的具体功能：你可以对比流出该节点的临时表（Output Table），相较于流入该节点的临时表（Input Table），发生了哪些变化。

# Storage界面介绍

## 技术背景介绍：BusTub的Storage Layer架构



## 界面操作说明

# Index界面介绍

## 技术背景介绍：BusTub的索引机制

## 界面操作说明

# SQL Logs界面介绍

## 界面操作说明

# 附录

## BusTub中常见的Planner Tree Node